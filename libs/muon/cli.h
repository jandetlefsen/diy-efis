/**
 * \mainpage CLI Parser
 *
 * \section intro 1. INTRODUCTION
 *
 * Many embedded system require a command-line interface (CLI). CLI 
 * commands are useful for debugging and testing. This library provides 
 * a simply yet feature-rich CLI infrastructure.
 *
 * The goal of CLI parser is to centralize the complexity of CLI features
 * such that developers do not need to spend a lot of time coding in order
 * to get the convenience of a modern, Cisco-like CLI.
 *
 * \section overview 2. OVERVIEW
 *
 * CLI parser simplifies command creation by introducing a .cli file 
 * syntax. Users create their commands by writing .cli file. A python 
 * script (provided by CLI parser) converts these .cli files into a 
 * list of C structures forming a parse tree. The parse tree is
 * then used by CLI parser to provide CLI in run-time.
 *
 * Users are responsible for providing the following:
 *
 * - .cli files - These files define CLI commands and are compiled by 
 *   mk_parser.py into a parse tree used by libparser.
 *
 * - Action functions - They are callback functions when a CLI command
 *   is accepted by CLI parser.
 *
 * - I/O functions - Prototypes of these functions are listed in cli_io.h.
 *   These functions connect CLI parser to the system I/O. For Linux/UNIX,
 *   these functions are provided. For other platforms, you will have to provide
 *   your own.
 *
 * CLI parser provides the following features:
 *
 * - Command completion
 * - Command recall
 * - Context sensitive help
 * - Automatic help generation
 *
 * The rest of the document are divided into the following sections:
 * - \ref cli - Describe the syntax of CLI files.
 * - \ref action - Describe how to write action functions.
 * - \ref app - Describe how to build an 
 *                application using CLI parser.
 * - \ref port - Describe how to port CLI parser to non-UNIX platforms.
 *
 * \section install 3. INSTALLATION
 *
 * To install CLI parser, obtain a .tar.gz file for CLI Parser. 
 * Unzip/untar it into a directory of UNIX machine. Go to the top-level 
 * directory of CLI Parser and issue: <tt>make -s unix</tt>. This
 * will create a build/unix directory which contains a library in
 * lib/libcparser.a and some test and demo programs in bin/. (The -s
 * flag is only used to suppress the actual issued command.) <i>On FreeBSD,
 * use gmake instead of make.</i> This is needed because I use some gmake
 * specific feature that is not supported by FreeBSD's make.
 *
 * \section license 4. LICENSING
 *
 * I have no intention of making a dime out of this work. I am more 
 * interested in having some tool that I like available to me regardless
 * of whatever job I take in the future. If you like what you see, feel
 * free to use. I delibrately use a modified BSD license because I don't
 * want people to worry about opening their own source and other legal
 * issue. If you make millions using this, more power to you! Regardless,
 * if you have any kind of feedbacks, drop me a note.
 *
 * \page cli CLI Files
 *
 * \section cli_intro 1. INTRODUCTION
 *
 * CLI files have suffix of .cli. Each CLI contains four types lines:
 * - Empty line
 * - Comment - Any line preceeded by '//' is a line of comment. '//'
 *   must be 1st character of the line.
 * - Directive - C style \#ifdef, \#ifndef, \#include, \#submode,
 *   \#endsubmode and \#end are available. The label is defined via 
 *   command-line arguments to mk_parser.py.
 * - Command definition - A command definition contains a sequence of 
 *   tokens separated by spaces.
 *
 * \section cli_empty 2. Empty Lines
 *
 * Empty lines can be inserted anywhere to make CLI files more readable.
 * However, it does have an implication on generating help displays.
 * See next section for details.
 *
 * \section cli_comment 3. Comments
 *
 * Each line of comment must begin with '//'. One cannot append
 * comments to a line of command or directive. A line of comment
 * immediately preceeding a line of command definition is automatically
 * included in the help display (generated by calling cli_help_cmd().)
 * cli_help_cmd() walks the parse tree and generating a summary of all
 * available commands. The comment immediately preceeding the command 
 * is saved as the description string of that command.
 *
 * For example, suppose we have the following command.
 *
 * <pre>
 * // Clear all interface counters
 * clear interface stats
 * </pre>
 *
 * cli_help() will generate the following:
 *
 * <pre>
 * Clear all interface counters
 *   clear interface stats
 * </pre>
 *
 * Note that if an empty line is inserted between the comment and the
 * command definition, the command will have an empty description string.
 *
 * \section cli_directive 4. Directive
 *
 * \subsection cli_directive_ifdef 4.1 Conditional Inclusion
 *
 * Directive are used to provide conditional inclusion of commands. 
 * For example, suppose we have an embedded system that runs on
 * both the actual hardware platform and on a Linux PC. Some of the
 * hardware diagnostic commands should not be included in the Linux
 * PC simulation.
 *
 * We can use \#ifdef/\#endif to conditionally define a set of commands.
 *
 * <pre>
 * \#ifdef HW_PLATFORM
 * register read <HEX:base_addr> { <HEX:num_words> }
 * register write <HEX:base_addr> <HEX:val>
 * \#endif
 * </pre>
 *
 * These two commands of peeking and poking H/W registers will only be
 * available if HW_PLATFORM is provided to mk_parser.py. To define
 * this label, pass "-D HW_PLATFORM" to mk_parser.py.
 *
 * \subsection cli_directive_include 4.2 CLI Files Inclusion
 *
 * When the number of commands becomes large, it is inconvenient to
 * hold all commands in a single .cli file. A \#include directive is
 * provided to allow file inclusion much like C header inclusion.
 *
 * For example, we can put the two H/W register command in a file 
 * called hw_reg.cli and rewrite the previous block as:
 *
 * <pre>
 * \#ifdef HW_PLATFORM
 * \#include "hw_reg.cli"
 * \#endif
 * </pre>
 * 
 * \subsection cli_directive_submode 4.3 Submode
 *
 * Submode allows the parser to switch to a different parse tree.
 * Submode is a useful feature for creating hierarchy in CLI.
 * Sometimes, a "flat" CLI structure can make it difficult to read
 * configuration. Suppose we have a network router with interfaces. 
 * We can configure it using a flat hierarchy.
 *
 * <pre>
 * interface eth0 ip-address 20.1.1.1 255.0.0.0
 * interface eth0 acl acl1
 * interface eth0 qos qos-profile1
 * </pre>
 *
 * or it can use submode to wrap all interface configurations.
 *
 * <pre>
 * interface eth0  <- enter interface submode.
 *  ip-adress 20.1.1.1 255.0.0.0
 *  acl acl1
 *  qos qos-profile1
 * </pre>
 *
 * By grouping all interface configuration commands inside interface
 * submode, it reduces the number of top-level commands. This has
 * an implication on the effectiveness of context sensitive help. If
 * a first-time user wants to see what top-level commands are 
 * available, he/she can be overwhelmed if all commands belong to
 * the top-level.
 *
 * To define commands in a submode, wrap those commands between
 * \#submode and \#endsubmode. For example, the interface submode
 * above looks like this:
 *
 * <pre>
 * interface <STRING:if_name>
 * \#submode "if"
 * ip-address <IPV4ADDR:addr> <IPV4ADDR:mask>
 * acl <STRING:acl_name>
 * qos <STRING:qos_name>
 * \#endsubmode
 * </pre>
 *
 * A \#submode directive requires a submode name. All submode action
 * functions are prefixed by this name after "cli_cmd_". For example, 
 * \#submode "if" means all its action functions are prefixed by 
 * "cli_cmd_if_". It must also follow a command. The command
 * that a \#submode directive follows is the command that enters the.
 * submode.
 *
 * Submodes can be nested. The total number of submode plus the top-
 * level is equal to CLI_MAX_NESTED_LEVELS.
 *
 * \section cli_command 5. Command Definitions
 *
 * The following are a list of currently supported tokens. There are
 * two classes of tokens - keywords and parameters. Keywords are
 * strings that form CLI commands. For example, the command
 * "show roster" consists of two keyword tokens ("show" and "roster"). 
 * Each keyword should be a string consists of alphabet, digits (0-9), 
 * '_' and '-'. Parameters are values entered by users. They have 
 * the form of <<i>type</i>:<i>var</i>> where <i>type</i> is the token type and <i>var</i> 
 * is a legal C variable name.
 *
 * CLI parser provides the following parameter token types:
 *
 * - STRING - A string without ' '.
 * - UINT16 - 32-bit unsigned integer in decimal or 
 *   hexadecimal. E.g. 0x1234, 312476.
 * - INT - 32-bit signed integer. E.g., -1234, 13469.
 * - HEX - 32-bit unsigned integer in form of hexadecimal 
 *   only. E.g., 0xabc1234.
 * - FLOAT - 64-bit floating point value. E.g., 0.134,
 *   -123.406.
 * - LIST - A string that takes on a set of keywords. Unlike other parameter 
 *   tokens, it takes on a unique form: <LIST:<i>kw1</i>,<i>kw2</i>,...:<i>var</i>> where 'kw#' 
 *   are valid keywords and 'var' is the name of the variable. The 
 *   intention of LIST keyword is reduce the number of similar commands. 
 *   For example, suppose one have three commands like:
 *   1) show interface ip-address,
 *   2) show interface mtu,
 *   3) show interface counters.
 *   One can simplify it to: show interface <LIST:ip-address,mtu,counters:options>.
 *   Note that there should not be any spaces between commas.
 *
 *
 * \subsection cli_extending 5.1 Extending CLI parser
 *
 * (<i>In the future, user can extend CLI parser by adding new token 
 * types.</i>)
 *
 * \subsection cli_optional 5.2 Optional parameters
 *
 * It is possible to include optional parameters in CLI commands. To
 * make a parameter optional, wrap it inside a pair of { }. For example,
 * suppose we define a command that adds 2 or 3 numbers:
 *
 * add <INT:a> <INT:b> { <INT:c> }
 *
 * The following are valid inputs: 
 *
 * <pre>
 * add 1 2 3
 * add 1 2
 * </pre>
 *
 * It is possible to have multiple optional parameters in a command but
 * they must be nested. For example, suppose we have a command that adds
 * two to four numbers:
 *
 * <pre>
 * LEGAL: add <INT:a> <INT:b> { <INT:c> { <INT:d> } }
 * ILLEGAL: add <INT:a> <INT:b> { <INT:c> } { <INT:d> }
 * </pre>
 *
 * There are couple reasons for imposing such restrictions. First,
 * a command with N optional parameters has only N possible acceptable
 * forms with the nesting constraint but 2^N forms without it. Second,
 * there are unresolvable ambiguities without the constraint.
 * 
 * Suppose user inputs "add 1 2 3". Is it c=3 and d is omitted or
 * c is omitted and d=3? With the nesting constraint, c must be 3
 * and d is omitted.
 * \page action Action Functions
 *
 * \section action_intro 1. INTRODUCTION
 *
 * An action function is the function called when a command is accepted
 * by CLI parser. This section describes how to write action functions
 * and what you can do with them.
 *
 * \section action_name 2. FUNCTION NAMING
 *
 * This function name is automatically generated from the command itself 
 * by: 
 * -# Concatenating all keywords and parameter variable names with '_'
 *    between them. This includes variable names of optional parameters.
 * -# Converting all '-' to '_'.
 * -# Prepending 'cli_cmd_' to it.
 *
 * For example, the command <tt>"save roster <STRING:filename>"</tt> expects an 
 * action function of <tt>"cli_cmd_save_roster_filename"</tt>.
 *
 * \section action_params 3. FUNCTION PARAMETERS
 *
 * The first argument of an action function is cli_t which 
 * provides some information about the parser state. (More on this later). 
 * Each parameter token type corresponds to the following C data type:
 *
 * - STRING -> char *
 * - UINT16 -> uint16_t 
 * - INT -> int32_t 
 * - HEX -> uint32_t 
 * - FLOAT -> double
 * - MACADDR -> cli_macaddr_t
 * - IPV4ADDR -> uint32_t 
 * - FILE -> char *
 *
 * All parameter tokens of a command are converted into pointers of their
 * corresponding C argument of the action function in order. For example,
 * we have a command <pre>"save roster { <STRING:filename> }"</pre> that
 * saves all employee record into a file. If 'filename' is not provided,
 * "default.dat" is used. The function prototype of its corresponding 
 * action function is:
 *
 * <pre>
 * result_t 
 * cli_cmd_save_roster(cli_t *context, char **filename);
 * </pre>
 *
 * The extra pointer is used to indicate if the parameter is present.
 * For optional parameter that is omitted, the pointer will be 0.
 * For parameters that exist (mandatory or optional), they will point to
 * valid data. You should check against 0 for each optional parameter
 * in your action functions. In our example, it may look something like 
 * this:
 *
 * <pre>
 * result_t 
 * cli_cmd_save_roster(cli_t *context, char **filename);
 * {
 *     char *fname = "default.dat";
 *     if (filename) {
 *         fname = *filename;
 *     }
 *     // Save the employee roster using 'fname'
 *     ...
 *     return s_ok;
 * }
 * </pre>
 *
 * \section action_retval 4. RETURNED VALUES
 *
 * Each action function must return a result_t. If there is no
 * error, return s_ok. Otherwise, return e_unexpected. The
 * processing of an action function is considered failed if the
 * requested action cannot be fullfilled. This can happen even though
 * CLI Parser does parameter checking because application specific
 * constraints cannot be checked. For example, if user enters 14 for 
 * a parameter token <UINT:month> which is supposed to be a valid
 * month from 1 to 12, the action function should reject the command
 * and return an error. (Returning an error does not alter CLI Parser
 * processing in anyways currently. In the future, it will increment
 * a counter.)
 *
 * \section action_submode 5. ENTERING AND LEAVING SUBMODE
 *
 * If submode is used, there must be a command for each submode to
 * enter it. Action function of that command should call 
 * cli_submode_enter(). An opaque pointer 'cookie' is provide to allow
 * some context of the submode. For example, going back to our interface
 * submode example, 'cookie' can point to the interface structure.
 * The command prompt can also change to indicate what submode you
 * are in; simply provide a string in 'prompt'.
 *
 * 'cookie' can be retrieved by the 'cookie' field of a cli_t
 * (passed in every action function). The first submode uses index 1.
 * The second (nested) submode uses index 2 and etc.
 *
 * When user enters a command to exit the submode, call 
 * cli_submode_exit().
 *
 * \section cli_api 7. OTHER USEFUL API
 *
 * \subsection cli_load 7.1 Loading A Script
 *
 * cli_load_cmd() feeds a text file into the parser. It automatically
 * exits submode by examining indentation. Submodes are indented from
 * its parent mode. If a line indentation is less than the previous line,
 * it automatically exits the submode. This behavior is identical to
 * Cisco CLI.
 *
 * \subsection cli_help 7.2 Display A Help Summary
 *
 * cli_help_cmd() generates a summary of all available commands in
 * the parse tree. The final output is similar to the original .cli
 * file (or files). This function provides a more convenient alternative
 * to creating a separate command that displays all available commands.
 * Since this function walks the compiled parse tree, it will never fail 
 * to list an existing command. If a separate help command is created,
 * developer may forget to update the help command when new commands are
 * introduced.
 *
 * It also have an optional filter string. If 'str' is non-0, it is *
 * used to filter out commands. Any command with a keyword that has 'str'
 * as a substring is displayed. All other commands are omitted. This
 * feature is useful when the number of commands in the system is very
 * large and user just want to find a small set of commands (possibly
 * with the same keywords or prefixes).
 *
 * \subsection cli_walk 7.3 Walk The Parse Tree
 *
 * cli_walk() walks through the entire parse tree and invokes 
 * up to two callbacks for each node. One application of this function
 * is cli_help_cmd(). Another example of this function application is
 * to save configuration. One can walk through the tree and locate all
 * commands that generate states. Each command can then regenerate CLI
 * commands that will recreate the state.
 *
 * \subsection cli_quit 7.4 Quit The Parser
 *
 * cli_quit() causes CLI parser to exit from cli_run().
 *
 * \subsection cli_user_input 7.5 User Input
 *
 * At times, it is useful if the CLI parser can accept user input.
 * cli_user_input() is provided to accept user input. Calling
 * this function puts the parser into a user state where an arbitrary
 * string is accepted. The buffer to hold the string is given in 
 * this function call. In addition, a callback function must be 
 * provided. The function returns immediately without accepting
 * any input. When \<ENTER\> is input, the callback function is
 * called.
 *
 * This approach may seem unnecessarily complicated at first sight.
 * However, it may be needed if the parser input does not come from
 * the terminal. For example, imagine the parser input is from a
 * network socket. Then, the process needs to return from
 * cli_user_input() call in order to receive the user input.
 * With the callback function, the way input is fed into the 
 * cparser is identical during normal parsing or during user input.
 * When \<ENTER\> is received in user input, the line is processed
 * just like a normal command.
 *
 * One can use this function to accept a password for entering
 * privileged mode. (In that case, <i>echoed</i> should be set to 0.)
 *
 * \page app Building Your Application
 *
 * \section app_intro 1. INTRODUCTION
 *
 * After defining your CLI commands and coding up action functions
 * for these commands, you need to incorporate these commands
 * (and their action functions) into your application.
 *
 * To do that,
 * -# Run mk_parser.py to compile all .cli files into the parse tree.
 * -# Call cli_init() to initialize a parser instance in your 
 *    application.
 * -# Call cli_run() or cli_input() to run the parser.
 * -# Compile your application with both the action functions and
 *    the parse tree linked in.
 *
 * \section app_mk_parser 2. COMPILING CLI FILES
 *
 * Use mk_parser.py to compile .cli files in a parse tree. mk_parser.py
 * takes in a set of -D flags (could be an empty set) and a set of 
 * .cli files and outputs a cli_tree.c, a cli_tree.h.
 *
 * cli_tree.c contains a set of C structures that form the parse tree.
 *
 * \section app_calls 3. ADDING CLI PARSER CALLS
 *
 * You can have multiple CLI parser sessions in your application. Each
 * parser instance is initialized by calling cli_init(). One needs 
 * to fill out all fields in cli_cfg_t. The 'root' field should be 
 * <pre>&cli_root</pre> defined in cli_tree.c. 'ch_complete', 
 * 'ch_erase', 'ch_del', and 'ch_help' are commonly '\\t', \<BS\> ('\\b'),
 * \<DEL\> (127), and '?' respectively. 'prompt' must be a 0-terminated 
 * string.
 * 
 * Run the parser instance when you are ready. There are two interfaces 
 * available - cli_input() and cli_run(). cli_input() is a 
 * low-level interface. You are responsible for getting all characters (from 
 * whatever source) and feed them into the parser one character at a time. 
 * cli_run() is a more automated interface. The user provides a set 
 * of parser I/O functions (see cli_io.h) and cli_run() will 
 * call them to get characters. It returns when the CLI session terminates.
 *
 * \subsection app_compile 4. COMPILING YOUR APPLICATION
 *
 * To build your application, include a rule for generating cli_tree.c
 * and another rule for compiling cli_tree.c and your .c file 
 * containing action functions. Link your application against libcparser.a.
 *
 * \subsection app_example 5. EXAMPLE
 *
 * A complete example is provided in build/unix/bin/test_parser. If run
 * withont any parameter, it is an automated unit test. To run it 
 * interactively, issue: 
 *
 * <pre>
 * test_parser -i
 * </pre>
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 * \page port Porting
 * 
 * \section port_intro 1. INTRODUCTION
 *
 * CLI parser is mostly platform-independent. However, there are couple
 * areas that needs to be rewritten/modified when porting to different
 * platforms - some basic data types and I/O subsystem
 *
 * \section port_types 2. BASIC DATA TYPES
 *
 * CLI Parser assumes the following types are defined - int32_t, uint32_t,
 * int16_t, uint16_t, uint8_t, int8_t. In Linux / MAC OS X, stdint.h defines
 * these types. If your platform does not have stdint.h, you will
 * need to define these types in cparser.h.
 *
 * \section port_io 2. I/O SUBSYSTEM
 * 
 * I/O subsystem refers to a set of functions that receives keystrokes
 * from users and sends output to user's screen. The default I/O assumes 
 * input comes from a UNIX terminate as stdin and output goes to stdout. 
 * If these are not true, you need to provide a set of functions to 
 * initialize, cleanup I/O subsystem, to read a character and to write 
 * a character and a string. cli_io.h provides the function prototype
 * of all I/O functions that needs to be rewritten when porting to a
 * different platforms.
 */

#ifndef __CLI_H__
#define __CLI_H__

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

/*
 * CLI Parser assumes the following types are defined: uint8_t, int8_t,
 * uint16_t, int16_t, uint32_t, int32_t. In many platforms (including
 * all platforms with GNU toolchain), stdint.h defines these types.
 * Thus, including this file is sufficient. If your platform does not 
 * have these types defined, you need to define them here.
 */
#include "../neutron/neutron.h"
#include <stdint.h>
 ////////////////////////////////////////////////////////////////////////////////
 //
 // String functions

  typedef char *string_t;
 /**
 * Create a new string_t string with the content specified by the 'init' pointer
 * If 0 is used for 'init' the string is initialized with zero bytes.
 *
 * The string is always null-termined (all the string_t strings are, always) so
 * even if you create an string_t string with:
 *
 * mystring = string_create_len("abc");
 *
 * You can print the string with printf() as there is an implicit \0 at the
 * end of the string. However the string is binary safe and can contain
 * \0 characters in the middle, as the length is stored in the string_t header.
 * @param init      string to initialize with
 * @param initlen   length of string to initialize with
 * @return new string.
 */
  extern string_t string_create(const char *init);
  /** Create a string, given an explicit length.
  */
  extern string_t string_create_len(const char *init, uint16_t len);
  /**
  * Duplicate a string.
  * @param s   String to duplicate
  * @return new string
  */
  extern string_t string_dup(const string_t s);
  /**
  * Return the length of the string
  * @param s   Stream to return length of
  * @return length of the string.
  */
  extern uint16_t string_length(const string_t s);
  /**
  * Free an string_t string. No operation is performed if 's' is 0.
  * @param s string to release
  */
  extern void string_free(string_t s);
  /**
  * Insert the characher ch into the string at pos
  * @param s
  * @param pos
  * @param ch
  * @return
  */
  extern string_t string_insert(string_t s, uint16_t pos, char ch);
  /**
  * Append the character to the end of the string and resize as needed
  * @param s   string to append to
  * @param ch  character to append
  * @return string with character appended
  */
  extern string_t string_push_back(string_t s, char ch);
  /**
  * Remove a character at pos
  * @param s
  * @param pos
  */
  extern void string_remove(string_t s, uint16_t pos);
  /**
  * Append the specified null termianted C string to the string_t string 's'.
  *
  * After the call, the passed string_t string is no longer valid and all the
  * references must be substituted with the new pointer returned by the call.
  * @param s     String to expand
  * @param t     new string to append
  * @return resized string
  */
  extern string_t string_cat(string_t s, const char *t);
  /**
  * Append the specified string_t 't' to the existing string_t 's'.
  *
  * @param s   String to append to
  * @param t   String to be appended
  * @return new string
  */
  extern string_t string_combine(string_t s, const string_t t);
  /**
  * Destructively modify the string_t string 's' to hold the specified binary
  * safe string pointed by 't' of length 'len' bytes.
  * @param s   String to copy to
  * @param t   Ansi string
  * @return new string
  */
  extern string_t string_copy(string_t s, const char *t);
  /**
  * Create a obtained using printf-alike format
  * specifier.
  *
  * After the call, the modified string_t string is no longer valid and all the
  * references must be substituted with the new pointer returned by the call.
  *
  * Example:
  *
  * s = string_create("Sum is: ");
  * s = string_printf(s,"%d+%d = %d",a,b,a+b).
  *
  * Often you need to create a string from scratch with the printf-alike
  * format. When this is the need, just use string_create_empty() as the target string:
  *
  * s = string_printf(string_create_empty(), "... your format ...", args);
  * @param s
  * @param fmt
  * @return
  */
  extern string_t string_printf(const char *fmt, ...); // __attribute__((format(printf, 1, 2)));
                                                       /**
                                                       * Like string_printf() but gets va_list instead of being variadic.
                                                       * @param s
                                                       * @param fmt
                                                       * @param ap
                                                       * @return
                                                       */
  extern string_t string_vprintf(const char *fmt, va_list ap);
  /**
  * printf to a string using a getarg callback.
  * @param fmt       Format for string
  * @param cb        Function to call back
  * @param parg      Opaque argument passed back
  * @return formatted string
  */
  extern string_t string_printf_cb(const char *fmt, get_arg_fn cb, void *parg);
  /**
  * Remove the part of the string from left and from right composed just of
  * contiguous characters found in 'cset', that is a null terminted C string.
  *
  *
  * Example:
  *
  * s = string_create("AA...AA.a.aa.aHelloWorld     :::");
  * s = string_trim(s,"Aa. :");
  * printf("%s\n", s);
  *
  * Output will be just "Hello World".
  * @param s
  * @param cset
  */
  extern void string_trim(string_t s, const char *cset);
  /**
  * Turn the string into a smaller (or equal) string containing only the
  * substring specified by the 'start' and 'end' indexes.
  *
  * The interval is inclusive, so the start and end characters will be part
  * of the resulting string.
  *
  * The string is modified in-place.
  *
  * Example:
  *
  * s = string_create("Hello World");
  * string_range(s,1,-1); => "ello World"
  * @param s
  * @param start
  * @param end
  */
  extern void string_substring(string_t s, uint16_t start, uint16_t end);
  /**
  * Modify an string_t string in-place to make it empty (zero length).
  * However all the existing buffer is not discarded but set as free space
  * so that next append operations will not require allocations up to the
  * number of bytes previously available.
  * @param s
  */
  extern void string_clear(string_t s);
  /**
  * Compare two string_t strings s1 and s2 with memcmp().
  *
  * Return value:
  *
  *     positive if s1 > s2.
  *     negative if s1 < s2.
  *     0 if s1 and s2 are exactly the same binary string.
  *
  * If two strings share exactly the same prefix, but one of the two has
  * additional characters, the longer string is considered to be greater than
  * the smaller one
  * @param s1
  * @param s2
  * @return
  */
  extern int string_compare(const string_t s1, const string_t s2);
  /**
  * Split 's' with separator in 'sep'. An array
  * of string_t strings is returned.
  * @param s     string to split
  * @param sep   separator to split string
  * @return a vector of the strings as split.
  */
  extern vector_t string_split(const char *s, char sep);
  /**
  * Free the result returned by string_split_len(), or do nothing if 'tokens' is 0.
  * @param tokens
  * @param count
  */
  extern void string_free_split(vector_t tokens);
  /**
  * Apply tolower() to every character of the string_t string 's'.
  * @param s
  */
  extern void string_tolower(string_t s);
  /**
  * Apply toupper() to every character of the string_t string 's'.
  * @param s
  */
  extern void string_toupper(string_t s);
  /**
  *  Modify the string substituting all the occurrences of the set of
  * characters specified in the 'from' string to the corresponding character
  * in the 'to' array.
  *
  * For instance: string_map_chars(mystring, "ho", "01", 2)
  * will have the effect of turning the string "hello" into "0ell1".
  *
  * @param s       string to translate
  * @param from    characters from
  * @param to      characters to
  */
  extern void string_translate(string_t s, const char *from, const char *to);
  /**
  * Return the total size of the allocation of the specifed string_t string,
  * including:
  * 1) The string_t header before the pointer.
  * 2) The string.
  * 3) The free buffer at the end if any.
  * 4) The implicit null term.
  * @param s
  * @return
  */
  extern uint16_t string_size(string_t s);
  /**
  * Ensure the buffer for the string is at least len bytes
  * @param s     string to resize, if 0 a new string is assigned
  * @param len   buffer required
  * @return resized string
  */
  extern string_t string_ensure_size(string_t s, uint16_t len);
  /**
  * Update the internal string length with the actual length of the string
  * @param s   string to set length of
  */
  extern void string_set_length(string_t s, uint16_t len);

/**
 * Maximum number of nested sub-mode levels.
 */
#define CLI_MAX_NESTED_LEVELS  (4)

/**
 * Maximum number of characters in one token.
 */
#define CLI_MAX_TOKEN_SIZE     (256)

/**
 * Maximum number of token per line.
 */
#define CLI_MAX_NUM_TOKENS     (32)

/**
 * Maximum number of lines.
 */
#define CLI_MAX_LINES          (10)

/**
 * If defined, support some of Emacs key binding.
 */
#define CLI_EMACS_BINDING

/*
 * This is to match Cisco CLI behavior. For example, if there is a
 * command "show crypto interfaces", one can just enter "sh cry int"
 * if no other command has the same prefix form.
 */
#define SHORTEST_UNIQUE_KEYWORD

struct _cli_t;

/**
 * Parser node type.
 */
typedef enum {
    CLI_NODE_ROOT = 0,
    CLI_NODE_END,
    CLI_NODE_KEYWORD,
    CLI_NODE_ENUM,
    CLI_NODE_PATH,
    CLI_NODE_STRING,
    CLI_NODE_UINT16,
    CLI_NODE_UINT32,
    CLI_NODE_INT16,
    CLI_NODE_INT32,
    CLI_NODE_FLOAT,
    CLI_NODE_SCRIPT,
    CLI_NODE_MATRIX,
    CLI_NODE_XYZ,
    CLI_MAX_NODES
} cli_node_type_t;

/**
 * A node in the parser tree. It has a node type which determines
 * what type of token is accepted.
 */
typedef struct cli_node_ {
    cli_node_type_t   type;      /**< Token type */ 
    uint32_t              flags;     /**< Flags */
    void                  *param;    /**< Token-dependent parameter */
    char                  *desc;     /**< A per-node description string */
    /** Pointer to the next sibling in the same level of the tree */
    struct cli_node_        *sibling;
    /** Pointer to all its children in the next level of the tree */
    struct cli_node_        *children;
} cli_node_t;

/**
 * \struct   cli_token_t
 * \brief    A parsed token.
 */
typedef struct cli_token_ {
    /** Index (in the line) of the beginning of the token */
    uint16_t begin_ptr;    // if -1 then
    string_t buffer;      /**< Local copy of the token */

    // if this is > then a string character " was detected and will be matched
    uint16_t in_string;
    /** 
     * Pointer to the parent node whose one of its children matches
     * this token.
     */
    cli_node_t *parent;
    /**
     * Pointer to the parse node that matches this token. Note that this
     * field is only filled out when the token is pushed into the stack.
     */
    cli_node_t *node;
} cli_token_t;

#define CLI_NODE_FLAGS_OPT_START          (1 << 1)
#define CLI_NODE_FLAGS_OPT_END            (1 << 2)
#define CLI_NODE_FLAGS_OPT_PARTIAL        (1 << 3)

#define VALID_PARSER(p)  (p)

/** Return the current line index */
#define CURRENT_LINE(p)  ((p)->cur_line)

/**
 * \struct   cli_line_t
 * \brief    A parser line structure.
 * \details  A parser line represents a line of user input in the parser.
 */
typedef struct {
    uint16_t  current;   /**< Point to the current character. */
    /** Buffer that holds the user input characters. */
    string_t buffer;
} cli_line_t;

/**
 * Return the number of tokens in the cparser for a particular parsed command.
 */
#define CLI_NUM_TOKENS(p)      (p->token_tos)

/**
 * User input callback. This function is called after a user input 
 * is completed.
 */
typedef result_t (*cli_input_cb)(struct _cli_t *context, string_t buffer);

/**
 * \struct   cli_cfg_
 * \brief    Contains all configurable parameters of a parser.
 */
typedef struct cli_cfg_ {
    cli_node_t  *root;
    char ch_complete;
    char ch_erase;
    char ch_del;
    char ch_help;
    string_t prompt;
    int32_t  flags;
    handle_t console_in;
    handle_t console_out;
    handle_t console_err;
} cli_cfg_t;

/**
 * \brief    Parser FSM states.
 * \details  There are 3 possible states in parser FSM.
 */
typedef enum cli_state_ {
    CLI_STATE_WHITESPACE = 0,
    CLI_STATE_TOKEN,
    CLI_STATE_ERROR,
    CLI_MAX_STATES
} cli_state_t;

/**
 * \brief    CLI parser structrure.
 * \details  This structure contains all configuration and running states.
 *           of a parser instance.
 */
typedef struct _cli_t {
    /** Parser configuration structure */
    cli_cfg_t     cfg;
    /** Current nested level */
    uint16_t  root_level;
    /** Parse tree root node at different nested levels */
    cli_node_t *root[CLI_MAX_NESTED_LEVELS];
    /** Parser prompt at different nested levels */
    string_t prompt[CLI_MAX_NESTED_LEVELS];
    // current registry key that is open
    memid_t current[CLI_MAX_NESTED_LEVELS];
    /** Current node */
    cli_node_t    *cur_node;

    /********** FSM states **********/
    cli_state_t   state;       /**< Current state */
    int16_t             token_tos;   /**< Token stack top pointer */
    int16_t             current_pos; /**< Current cursor in the line */
    /** Last cursor position that is in a non-error state */
    int16_t             last_good;
    /** Token stack */
    cli_token_t   tokens[CLI_MAX_NUM_TOKENS]; /* parsed tokens */

    /********** Line buffering states **********/
    int16_t             max_line;
    int16_t             cur_line;
    cli_line_t          lines[CLI_MAX_LINES];

    /** Flag indicating if the parser should continue to except input */
    bool               done;   

    /********** User input **********/
    /** Pointer to the buffer provided by user for input */
    string_t user_buf;
    /** Whether to echo user input */
    bool               user_do_echo;
    /** Callback function when the input is complete */
    cli_input_cb  user_input_cb;

    /********** Last executed command **********/
    /** Index to the line buffer that holds the command */
    int               last_line_idx;
    /** Result code of the command */
    result_t  last_rc;
    /** End node of the command. 0 if the command is invalid. */
    cli_node_t    *last_end_node;
} cli_t;

typedef result_t (*cli_glue_fn)(cli_t *parser);
typedef result_t (*cli_token_fn)(char *token, int token_len,
                                             int *is_complete);

static inline memid_t get_context(cli_t *parser)
  {
  return parser->current[parser->root_level];
  }
/**
 * Character type return by cli_getch().
 */
typedef enum {
    CLI_CHAR_UNKNOWN = 0, /**< Character that cannot be classified */
    CLI_CHAR_REGULAR,     /**< All alpha-numeric + punctuation charcters */
    CLI_CHAR_UP_ARROW,    /**< Up arrow (recall previous command) */
    CLI_CHAR_DOWN_ARROW,  /**< Down arrow (recall next command) */
    CLI_CHAR_LEFT_ARROW,  /**< Left arrow (prev. character in the command) */
    CLI_CHAR_RIGHT_ARROW, /**< Right arrow (next character in the command) */
    CLI_CHAR_FIRST,       /**< Go to the first character in the command */
    CLI_CHAR_LAST,        /**< Go to the first character in the command */
    CLI_MAX_CHAR
} cli_char_t;

/**
 * \typedef  cli_walker_fn
 * \brief    Walker function prototype used in cli_walk().
 *
 * \param    parser Pointer to the parser structure.
 * \param    node   Pointer to the current node being walked.
 * \param    cookie An opaque pointer passed from cli_walk().
 *
 * \return   s_ok to continue the walk; e_unexpected to abort.
 */
typedef result_t (*cli_walker_fn)(cli_t *parser, cli_node_t *node, void *cookie);

/**
 * \brief    Initialize a parser.
 *
 * \param    cfg Pointer to the parser configuration structure.
 *
 * \retval   parser Pointer to the initialized parser.
 * \return   s_ok if succeeded; e_unexpected if failed.
 */
extern result_t cli_init(cli_cfg_t *cfg, cli_t *parser);

/**
 * \brief    Input a character to the parser.
 *
 * \param    parser  Pointer to the parser structure.
 * \param    ch      Character to be input.
 * \param    ch_type Character type.
 *
 * \return   s_ok if succeeded; e_unexpected if failed.
 */
extern result_t cli_input(cli_t *parser, char ch, cli_char_t ch_type);

/**
 * \brief    Run the parser. 
 * \details  This function is a wrapper around cli_input(). It first 
 *           calls cli_io_init(). Then, it calls cli_getch() and 
 *           feeds character into the parser until it quits.
 *
 * \param    parser Pointer to the parser structure.
 *
 * \return   s_ok if succeeded; e_unexpected if failed.
 */
extern result_t cli_run(cli_t *parser);

/**
 * \brief    Walk the parse tree in the parser.
 *
 * \param    parser  Pointer to the parser structure.
 * \param    pre_fn  Walker function that called before tranverse its children.
 * \param    post_fn Walker function that called after transvere its children.
 * \param    cookie  An opaque pointer that is passed back to the caller via
 *                   callback functions 'pre_fn' and 'post_fn'.
 *
 * \return   s_ok if succeeded; e_unexpected if failed.
 */
extern result_t cli_walk(cli_t *parser, cli_walker_fn pre_fn,
                              cli_walker_fn post_fn, void *cookie);

/**
 * \brief    Walk the parser tree and generate a list of all available commands.
 *
 * \param    parser Pointer to the parser structure.
 * \param    str    Pointer to a filter string. If it is 0, all
 *                  commands in the parse tree are displayed. Otherwise,
 *                  only commands with keywords that contain 'str' as
 *                  a substring are displayed.
 *
 * \return   s_ok if succeeded; e_bad_parameter if 
 *           the parser structure is invalid.
 */
extern result_t cli_help_cmd(cli_t *parser, char *str);

/**
 * \brief    Load a command/config file to the parser. 
 * \details  A command/config file is just a text file with CLI commands. 
 *           (One command per line.) The only difference is that submode 
 *           is automatically exited if the indentation changes. This 
 *           behavior is the same as Cisco CLI.
 *
 * \param    parser   Pointer to the parser structure.
 * \param    filename Pointer to the filename.
 *
 * \return   s_ok if succeeded; e_bad_parameter
 *           if the input parameters are 0; e_unexpected if the file
 *           cannot be opened.
 */
extern result_t cli_load_cmd(cli_t *parser, char *filename);

/**
 * \brief    Exit a parser session.
 * \details  This call causes the parser to exit and returns from 
 *           cli_run().
 *
 * \param    parser - Pointer to the parser structure.
 *
 * \return   s_ok if succeeded; e_bad_parameter if failed.
 */
extern result_t cli_quit(cli_t *parser);

/**
 * Enter a submode
 * @param parser    The parser structure
 * @param key       Key to set the root for the mode
 * @param prompt    Prompt for the submode
 * @return s_ok if succeeded; e_bad_parameter if the input 
 *           parameters are invalid; e_unexpected if there too many levels 
 *           of submode already.
 */
extern result_t cli_submode_enter(cli_t *parser, memid_t key, string_t prompt);

/**
 * \brief    Leave a submode. 
 * \details  The previous mode context and prompt are automatically restored.
 *
 * \param    parser Pointer to the parser structure.
 *
 * \return   s_ok if succeeded; e_bad_parameter if the input 
 *           parameters are invalid; e_unexpected if the parser has not 
 *           entered any submode.
 */
extern result_t cli_submode_exit(cli_t *parser);
/**
 * \brief    Read a raw string from the user via the terminal.
 *
 * \param    parser   Pointer to the parser structure.
 * \param    prompt   Pointer to a prompt string. If 0, nothing is printed.
 * \param    echoed   1 to echo the input; 0 otherwise.
 * \param    cb       Callback function that is called when input is complete.
 *
 * \return   s_ok if succeeded;
 *           e_bad_parameter if the input parameters are invalid.
 */
extern result_t cli_user_input(cli_t *parser, const char *prompt,
                                    int echoed, cli_input_cb cb);
/**
 * \brief    Match function pointer.
 * \details  This function pointer is the prototype of all
 *           CLI Parser match functions.
 *
 * \param    token     Pointer to the token.
 * \param    token_len Number of valid characters in the token.
 * \param    node      The parse tree node to be matched against.
 *
 * \retval   is_complete Return 1 from if the token matches the entire
 *                       token; 0 otherwise.
 * \return   s_ok if it is a complete or partial match; 
 *           e_unexpected if it does match the node.
 */
typedef result_t (*cli_match_fn)(cli_t *context, cli_token_t *token,  cli_node_t *node, bool *is_complete);

/**
 * \brief    Completion function pointer.
 * \details  This function pointer is the prototype of all
 *           CLI Parser match functions.
 *
 * \param    parser    Pointer to the parser.
 * \param    node      Pointer to the current matching parse node.
 * \param    token     Pointer to the token.
 * \param    token_len Number of valid characters in the token.
 */
typedef result_t (*cli_complete_fn)(cli_t *context,
                                    const cli_node_t *node,
                                    cli_token_t *token);

/**
 * \brief    Get function pointer.
 * \details  This function pointer is the prototype of all CLI Parser 
 *           get functions.
 *
 * \param    token     Pointer to the token.
 *
 * \retval   val       Pointer to the returned parameter value.
 * \return   s_ok if succeeded; e_unexpected otherwise.
 */
typedef result_t (*cli_get_fn)(cli_t *context, const cli_token_t *token, void *val);

extern cli_match_fn    cli_match_fn_tbl[CLI_MAX_NODES];
extern cli_complete_fn cli_complete_fn_tbl[CLI_MAX_NODES];


// this structure describes an enumeration
// MUST be sorted in name order or the completions won't work
// the values can be any order
typedef struct _enum_t {
  const char *name;
  uint16_t value;
  } enum_t;

/********** Token complete functions **********/
extern result_t cli_complete_keyword(cli_t *parser, const cli_node_t *node, cli_token_t *token);
extern result_t cli_complete_enum(cli_t *parser, const cli_node_t *node, cli_token_t *token);
extern result_t cli_complete_path(cli_t *parser, const cli_node_t *node, cli_token_t *token);

extern result_t match_path(cli_t *context, string_t path, bool ignore_wildcard, memid_t *key, vector_t *matches);

/********** Token get functions **********/
extern result_t cli_get_string(const cli_token_t *token, string_t *value);
extern result_t cli_get_path(const cli_token_t *token, string_t *value);
extern result_t cli_get_uint16(const cli_token_t *token, uint16_t *value);
extern result_t cli_get_uint32(const cli_token_t *token, uint32_t *value);
extern result_t cli_get_int16(const cli_token_t *token, int16_t *value);
extern result_t cli_get_int32(const cli_token_t *token, int32_t *value);
extern result_t cli_get_float(const cli_token_t *token, float *value);
extern result_t cli_get_script(const cli_token_t *token, string_t *value);
extern result_t cli_get_matrix(const cli_token_t *token, matrix_t *value);
extern result_t cli_get_xyz(const cli_token_t *token, xyz_t *value);
extern result_t cli_get_enum(const cli_token_t *token, const enum_t *enums, uint16_t *value);
extern result_t cli_get_bool(const cli_token_t *token, const enum_t *enums, bool *value);
extern result_t convert_string_to_enum(const string_t token, const enum_t *enums, uint16_t *value);


/**
 * \brief    Print the CLI prompt.
 * \details  If in privileged mode, prepend a '+'.
 *
 * \param    parser Pointer to the parser structure.
 */
extern void cli_print_prompt(const cli_t *parser);
/**
 * Reset a line buffer into an "empty" state.
 *
 * \param    line Pointer to a line structure.
 *
 * \return   s_ok if succeeded; e_bad_parameter if the line 
 *           is 0.
 */ 
extern result_t cli_line_reset(cli_line_t *line);
/**
 * Initialize a line buffer.
 */
result_t cli_line_init(cli_line_t *line);
/**
 * Insert a character into a line buffer at the current position.
 *
 * \param    parser Pointer to a parser structure.
 * \param    ch     Character to be inserted.
 *
 * \return   s_ok if succeeded; e_bad_parameter if inputs
 *           are invalid; e_no_space if the line buffer is full.
 */
extern result_t cli_line_insert(cli_t *parser, char ch);

/**
 * Delete a character from the line buffer immediately before
 * the current position. The current position is moved back by one.
 *
 * \param    parser Pointer to a parser structure.
 *
 * \return   s_ok if succeeded; e_bad_parameter if inputs
 *           are invalid; e_not_found if the line buffer is empty.
 */
extern result_t cli_line_delete(cli_t *parser);

/**
 * Move the current position of the current line to the next character.
 *
 * \param    parser Pointer to the parser structure.
 *
 * \return   A character to be fed into parser FSM; 0 if no character
 *           is to be fed.
 */
extern char cli_line_next_char(cli_t *parser);

/**
 * Move the current position of the current line to the previous character.
 *
 * \param    parser Pointer to the parser structure.
 *
 * \return   A character to be fed into parser FSM; 0 if no character
 *           is to be fed.
 */
extern char cli_line_prev_char(cli_t *parser);

/**
 * Move the current line to the next line.
 *
 * \param    parser Pointer to the parser structure.
 *
 * \return   s_ok if succeeded; e_bad_parameter if inputs
 *           are invalid.
 */
extern result_t cli_line_next_line(cli_t *parser);

/**
 * Move the current line to the previous line.
 *
 * \param    parser Pointer to the parser structure.
 *
 * \return   s_ok if succeeded; e_bad_parameter if inputs
 *           are invalid.
 */
extern result_t cli_line_prev_line(cli_t *parser);

/**
 * Print the current line including the current line.
 *
 * \param    parser       Pointer to the parser structure.
 * \param    print_prompt 1 if the parser prompt should be printed first.
 * \param    new_line     1 if a linefeed should be printed first;
 *                        0 otherwise.
 *
 * \return   None. Crash on failure.
 */
extern result_t cli_line_print(const cli_t *parser, int print_prompt, int new_line);

/**
 * Return the current position of the current line.
 *
 * \param    parser Pointer to the parser structure.
 *
 * \return   Current position of the current line.
 */
extern uint16_t cli_line_current(const cli_t *parser);

/**
 * Return the last position of the current line.
 *
 * \param    parser Pointer to the parser structure.
 *
 * \return   Last position of the current line. This index points to
 *           the terminating 0 character of the current line.
 */
extern uint16_t cli_line_last(const cli_t *parser);

/**
 * Return the character of the the current position of the current line.
 *
 * \param    parser Pointer to the parser structure.
 *
 * \return   Character of the current position of the current line.
 */
extern char cli_line_current_char(const cli_t *parser);

extern char cli_line_char(const cli_t *parser, uint16_t pos);

extern result_t cli_line_advance(cli_t *parser);
#define CUR_TOKEN(p) (&((p)->tokens[(p)->token_tos]))

/**
 * Reset all parser FSM states.
 *
 * \param    parser Pointer to the parser structure.
 *
 * \return   None.
 */
extern void cli_fsm_reset(cli_t *parser);

/**
 * Input a character to parser FSM.
 *
 * \param    parser Pointer to the parser structure.
 * \param    ch     Input character.
 *
 * \return   s_ok if succeeded; e_unexpected otherwise.
 */
extern result_t cli_fsm_input(cli_t *parser, char ch);

/**
 * Walk through all children of a node. Return a match node if one is found.
 *
 * \param    parser    Pointer to the parser structure.
 * \param    token     Pointer to the beginning of the token.
 * \param    parent    Pointer to the parent node.
 *
 * \retval   match       Pointer to a node that matches the token.
 *                       If there are multiple matches, the highest priority match
 *                       is returned.
 * \retval   is_complete 1 if the token completely matches 
 * \return   Number of matches.
 */
extern int cli_match(cli_t *parser, cli_token_t *token,
                  cli_node_t *parent, cli_node_t **match,
                  bool *is_complete);

#ifdef __cplusplus
}
#endif /* __cplusplus */

#endif /* __CLI_H__ */
